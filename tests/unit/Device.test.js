const Device = require("../../classes/device/Device");

describe("Device", () => {
  describe("constructor", () => {
    let name;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = () => {
      payload = { name: name };
      return new Device(payload);
    };

    it("should create new Device and set its name", () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result.Name).toEqual(name);
    });

    it("should initiazle variables to empty object", () => {
      let result = exec();

      expect(result.Variables).toEqual({});
    });

    it("should initiazle event object", () => {
      let result = exec();

      expect(result.Events).toBeDefined();
    });

    it("should set type to undefined", () => {
      let result = exec();

      expect(result.Type).not.toBeDefined();
    });

    it("should throw if payload is empty", () => {
      expect(() => new Device()).toThrow();
    });

    it("should throw if payload has no name", () => {
      expect(() => new Device({})).toThrow();
    });

    it("should create variable on the basis of payload that can be generated by payload", () => {
      let device1 = new Device({ name: "device1" });
      let device1Payload = device1.Payload;

      let device2 = new Device(device1Payload);

      expect(device2.Payload).toBeDefined();
      expect(device2.Payload).toEqual(device1.Payload);

      expect(device2.Id).toEqual(device1.Id);
      expect(device2.Name).toEqual(device1.Name);
    });
  });

  describe("get Events", () => {
    let name;
    let device;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      return device.Events;
    };

    it("should return EventEmitter of device", () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result).toEqual(device._events);
    });
  });

  describe("get Name", () => {
    let name;
    let device;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      return device.Name;
    };

    it("should return Name of device", () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result).toEqual(name);
    });
  });

  describe("get Variables", () => {
    let name;
    let device;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      return device.Variables;
    };

    it("should return Name of device", () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result).toEqual(device._variables);
    });
  });

  describe("get Variable", () => {
    let name;
    let device;
    let payload;
    let var1;
    let var2;
    let var3;
    let getId;

    beforeEach(() => {
      name = "test name";
      var1 = { Id: 101 };
      var2 = { Id: 102 };
      var3 = { Id: 103 };
      getId = 102;
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      device.addVariable(var1);
      device.addVariable(var2);
      device.addVariable(var3);
      return device.getVariable(getId);
    };

    it("should return variable of given id", () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result).toEqual(var2);
    });

    it("should return undefined if there is no variable of given id", () => {
      getId = 1234;
      let result = exec();

      expect(result).not.toBeDefined();
    });
  });

  describe("get Type", () => {
    let name;
    let device;
    let payload;
    let type;

    beforeEach(() => {
      name = "test name";
      type = "test type";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      device._type = type;
      return device.Type;
    };

    it("should return Type of device", () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result).toEqual(type);
    });
  });

  describe("get Payload", () => {
    let name;
    let payload;
    let device;

    beforeEach(() => {
      name = "test name";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      return device.Payload;
    };

    it("should return device payload", () => {
      let result = exec();

      let validPayload = {
        name: device.Name,
        id: device.Id
      };

      expect(result).toBeDefined();
      expect(result).toMatchObject(validPayload);
    });
  });

  describe("addVariable", () => {
    let name;
    let device;
    let variable;
    let variableId;
    let payload;

    beforeEach(() => {
      name = "test name";
      variableId = "test variable";
      variable = { Id: variableId };
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      device.addVariable(variable);
    };

    it("should add variable to variables", () => {
      exec();

      expect(device.Variables[variableId]).toBeDefined();
      expect(device.Variables[variableId]).toEqual(variable);
    });

    it("should add variable again after it was deleted", () => {
      exec();
      device.removeVariable(variable.Id);
      device.addVariable(variable);
      expect(device.Variables[variableId]).toBeDefined();
      expect(device.Variables[variableId]).toEqual(variable);
    });

    it("should replace given variable if name already existis", () => {
      exec();
      let newVariable = { Id: variableId, Name: "new" };

      device.addVariable(newVariable);
      expect(device.Variables[variableId]).not.toEqual(variable);
      expect(device.Variables[variableId]).toEqual(newVariable);
    });
  });

  describe("removeVariable", () => {
    let name;
    let device;
    let variable;
    let variableId;
    let payload;

    beforeEach(() => {
      name = "test name";
      variableId = "test variable";
      variable = { Id: variableId };
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      device.addVariable(variable);
      device.removeVariable(variableId);
    };

    it("should remove variable from variables", () => {
      exec();

      expect(device.Variables[variableId]).not.toBeDefined();
    });

    it("should throw if there is no variable of such id", () => {
      payload = { name: name };
      device = new Device(payload);
      device.addVariable(variable);

      let newVariable = { Id: "new test Id" };

      expect(() => device.removeVariable(newVariable)).toThrow();
    });
  });

  describe("divideVariablesByTickId", () => {
    let variable1;
    let variable2;
    let variable3;
    let variable4;
    let variable5;
    let variable6;
    let variable7;
    let variable8;
    let variable9;
    let variable10;
    let variables;

    beforeEach(() => {
      variable1 = { Name: "var1", TickId: 1 };
      variable2 = { Name: "var2", TickId: 1 };
      variable3 = { Name: "var3", TickId: 2 };
      variable4 = { Name: "var4", TickId: 2 };
      variable5 = { Name: "var5", TickId: 3 };
      variable6 = { Name: "var6", TickId: 3 };
      variable7 = { Name: "var7", TickId: 4 };
      variable8 = { Name: "var8", TickId: 4 };
      variable9 = { Name: "var9", TickId: 5 };
      variable10 = { Name: "var10", TickId: 5 };

      variables = [
        variable1,
        variable2,
        variable3,
        variable4,
        variable5,
        variable6,
        variable7,
        variable8,
        variable9,
        variable10
      ];
    });

    let exec = () => {
      return Device.divideVariablesByTickId(variables);
    };

    it("should split variables by TickIds", () => {
      let result = exec();
      expect(result).toBeDefined();

      let allTickIds = Object.keys(result);
      expect(allTickIds.length).toEqual(5);

      expect(result).toMatchObject({
        "1": [variable1, variable2],
        "2": [variable3, variable4],
        "3": [variable5, variable6],
        "4": [variable7, variable8],
        "5": [variable9, variable10]
      });
    });

    it("should split variables by TickIds if there is only one tickIds", () => {
      variable1 = { Name: "var1", TickId: 6 };
      variable2 = { Name: "var2", TickId: 6 };
      variable3 = { Name: "var3", TickId: 6 };
      variable4 = { Name: "var4", TickId: 6 };
      variable5 = { Name: "var5", TickId: 6 };
      variable6 = { Name: "var6", TickId: 6 };
      variable7 = { Name: "var7", TickId: 6 };
      variable8 = { Name: "var8", TickId: 6 };
      variable9 = { Name: "var9", TickId: 6 };
      variable10 = { Name: "var10", TickId: 6 };

      variables = [
        variable1,
        variable2,
        variable3,
        variable4,
        variable5,
        variable6,
        variable7,
        variable8,
        variable9,
        variable10
      ];

      let result = exec();
      expect(result).toBeDefined();

      let allTickIds = Object.keys(result);
      expect(allTickIds.length).toEqual(1);

      expect(result).toMatchObject({
        "6": [
          variable1,
          variable2,
          variable3,
          variable4,
          variable5,
          variable6,
          variable7,
          variable8,
          variable9,
          variable10
        ]
      });
    });
  });

  describe("refresh", () => {
    let name;
    let payload;
    let device;
    let tickNumber;
    let _refreshMock;
    let _refreshMockResolvedValue;
    let eventEmitterMock;
    let eventEmitterMockEmitMethod;

    beforeEach(() => {
      name = "test name";
      tickNumber = 15;
      _refreshMockResolvedValue = 1234;
      eventEmitterMockEmitMethod = jest.fn();
      eventEmitterMock = { emit: eventEmitterMockEmitMethod };
    });

    let exec = () => {
      payload = { name: name };
      _refreshMock = jest.fn().mockResolvedValue(_refreshMockResolvedValue);
      device = new Device(payload);
      device._refresh = _refreshMock;
      device._events = eventEmitterMock;

      return device.refresh(tickNumber);
    };

    it("should call _refresh method with tick arguments", async () => {
      let result = await exec();

      expect(_refreshMock).toHaveBeenCalledTimes(1);
      expect(_refreshMock.mock.calls[0][0]).toEqual(tickNumber);
    });

    it("should invoke Refreshed Event with _refresh result if refresh result is not empty", async () => {
      let result = await exec();

      expect(eventEmitterMockEmitMethod).toHaveBeenCalledTimes(1);
      expect(eventEmitterMockEmitMethod.mock.calls[0][0]).toEqual("Refreshed");
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][0]).toEqual(device);
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][1]).toEqual(
        _refreshMockResolvedValue
      );
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][2]).toEqual(
        tickNumber
      );
    });

    it("should not invoke Refreshed Event if refresh result is empty", async () => {
      _refreshMockResolvedValue = null;

      let result = await exec();

      expect(eventEmitterMockEmitMethod).not.toHaveBeenCalled();
    });
  });

  describe("_generatePayload", () => {
    let name;
    let payload;
    let device;

    beforeEach(() => {
      name = "test name";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      return device._generatePayload();
    };

    it("should return device payload", () => {
      let result = exec();

      let validPayload = {
        name: device.Name,
        id: device.Id
      };

      expect(result).toBeDefined();
      expect(result).toMatchObject(validPayload);
    });
  });

  describe("editWithPayload", () => {
    let name;
    let payload;
    let device;
    let nameToEdit;
    let payloadToEdit;

    beforeEach(() => {
      name = "test name";
      nameToEdit = "new test name";
    });

    let exec = () => {
      payload = { name: name };
      device = new Device(payload);
      payloadToEdit = { name: nameToEdit };
      return device.editWithPayload(payloadToEdit);
    };

    it("should edit device according to payload", async () => {
      await exec();

      expect(device.Name).toBeDefined();
      expect(device.Name).toEqual(nameToEdit);
    });

    it("should not edit name if name is not defined in payload", async () => {
      nameToEdit = undefined;
      await exec();

      expect(device.Name).toBeDefined();
      expect(device.Name).toEqual(name);
    });
  });
});
