const Device = require("../../../classes/device/Device");
const config = require("config");
const path = require("path");

let {
  clearDirectoryAsync,
  checkIfTableExists,
  checkIfColumnExists,
  checkIfFileExistsAsync,
  createDatabaseFile,
  createDatabaseTable,
  createDatabaseColumn,
  readAllDataFromTable,
  snooze
} = require("../../../utilities/utilities");

describe("Device", () => {
  let db1Path;
  let db2Path;

  beforeEach(async () => {
    db1Path = config.get("db1Path");
    db2Path = config.get("db2Path");
  });

  afterEach(async () => {
    await clearDirectoryAsync(db1Path);
    await clearDirectoryAsync(db2Path);
  });

  describe("constructor", () => {
    let exec = async () => {
      return new Device();
    };

    it("should create new device and set initialized to false", async () => {
      let result = exec();

      expect(result).toBeDefined();
      expect(result.Initialized).toBeFalsy();
    });
  });

  describe("init", () => {
    let name;
    let payload;
    let device;

    beforeEach(() => {
      name = "test name";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device(payload);
      return device.init(payload);
    };

    it("should create new Device and set its name", async () => {
      await exec();

      expect(device).toBeDefined();
      expect(device.Name).toEqual(name);
    });

    it("should initialize variables to empty object", async () => {
      await exec();

      expect(device.Variables).toEqual({});
    });

    it("should initialize calculation elements to empty object", async () => {
      await exec();

      expect(device.CalculationElements).toEqual({});
    });

    it("should initialize event object", async () => {
      await exec();

      expect(device.Events).toBeDefined();
    });

    it("should set type to undefined", async () => {
      await exec();

      expect(device.Type).not.toBeDefined();
    });

    it("should set initialized to true", async () => {
      await exec();

      expect(device.Initialized).toBeTruthy();
    });

    it("should throw if payload is empty", async () => {
      await expect(
        new Promise(async (resolve, reject) => {
          try {
            device = new Device();
            await device.init();
            return resolve(true);
          } catch (err) {
            return reject(err);
          }
        })
      ).rejects.toBeDefined();
    });

    it("should throw if payload has no name", async () => {
      await expect(
        new Promise(async (resolve, reject) => {
          try {
            device = new Device();
            await device.init({});
            return resolve(true);
          } catch (err) {
            return reject(err);
          }
        })
      ).rejects.toBeDefined();
    });

    it("should create device on the basis of payload that can be generated by payload", async () => {
      let device1 = new Device();
      await device1.init({ name: "device1" });

      let device1Payload = device1.Payload;

      let device2 = new Device(device1Payload);
      await device2.init(device1Payload);

      expect(device2.Payload).toBeDefined();
      expect(device2.Payload).toEqual(device1.Payload);

      expect(device2.Id).toEqual(device1.Id);
      expect(device2.Name).toEqual(device1.Name);
    });

    it("should init archive manager", async () => {
      await exec();

      expect(device.ArchiveManagerInitialized).toBeTruthy();
    });

    it("should create database file associated with id", async () => {
      await exec();

      let filePath = path.join(db1Path, `archive_${device.Id}.db`);
      let fileExists = await checkIfFileExistsAsync(filePath);
      expect(fileExists).toEqual(true);
    });

    it("should create table data in db file", async () => {
      await exec();

      let filePath = path.join(db1Path, `archive_${device.Id}.db`);
      let fileExists = await checkIfTableExists(filePath, "data");
      expect(fileExists).toEqual(true);
    });
  });

  describe("_initCalculationElements", () => {
    let name;
    let payload;
    let device;

    let calculationElement1Id;
    let calculationElement1Type;
    let calculationElement1Archived;
    let calculationElement1Name;
    let calculationElement1SampleTime;
    let calculationElement1Payload;
    let calculationElement1Variables;
    let calculationElement1Add;

    let calculationElement2Id;
    let calculationElement2Type;
    let calculationElement2Archived;
    let calculationElement2Name;
    let calculationElement2SampleTime;
    let calculationElement2Payload;
    let calculationElement2Add;

    let calculationElement3Id;
    let calculationElement3Type;
    let calculationElement3Archived;
    let calculationElement3Name;
    let calculationElement3SampleTime;
    let calculationElement3Payload;
    let calculationElement3Variables;
    let calculationElement3Add;

    let calculationElementVariablesPayload;

    beforeEach(() => {
      name = "test name";

      calculationElement1Id = "1001";
      calculationElement1Type = "sumElement";
      calculationElement1Archived = true;
      calculationElement1Name = "test calculation element1";
      calculationElement1SampleTime = 1;
      //variables have to be empty - device doesn't have any variables!
      calculationElement1Variables = [];
      calculationElement1Add = true;

      calculationElement2Id = "1002";
      calculationElement2Type = "sumElement";
      calculationElement2Archived = true;
      calculationElement2Name = "test calculation element2";
      calculationElement2SampleTime = 2;
      //variables have to be empty - device doesn't have any variables!
      calculationElement2Variables = [];
      calculationElement2Add = true;

      calculationElement3Id = "1003";
      calculationElement3Type = "sumElement";
      calculationElement3Archived = true;
      calculationElement3Name = "test calculation element3";
      calculationElement3SampleTime = 2;
      //variables have to be empty - device doesn't have any variables!
      calculationElement3Variables = [];
      calculationElement3Add = true;
    });

    let exec = async () => {
      calculationElementVariablesPayload = [];

      calculationElement1Payload = {
        id: calculationElement1Id,
        type: calculationElement1Type,
        archived: calculationElement1Archived,
        name: calculationElement1Name,
        sampleTime: calculationElement1SampleTime,
        variables: calculationElement1Variables
      };

      calculationElement2Payload = {
        id: calculationElement2Id,
        type: calculationElement2Type,
        archived: calculationElement2Archived,
        name: calculationElement2Name,
        sampleTime: calculationElement2SampleTime,
        variables: calculationElement2Variables
      };

      calculationElement3Payload = {
        id: calculationElement3Id,
        type: calculationElement3Type,
        archived: calculationElement3Archived,
        name: calculationElement3Name,
        sampleTime: calculationElement3SampleTime,
        variables: calculationElement3Variables
      };

      if (calculationElement1Add)
        calculationElementVariablesPayload.push(calculationElement1Payload);

      if (calculationElement2Add)
        calculationElementVariablesPayload.push(calculationElement2Payload);

      if (calculationElement3Add)
        calculationElementVariablesPayload.push(calculationElement3Payload);

      payload = {
        name: name
      };

      device = new Device(payload);
      await device.init(payload);
      await device._initCalculationElements(calculationElementVariablesPayload);
    };

    it("should create calculationElements based on payload", async () => {
      await exec();

      expect(Object.keys(device.CalculationElements).length).toEqual(3);
      expect(device.CalculationElements[calculationElement1Id]).toBeDefined();

      expect(device.CalculationElements[calculationElement1Id].Id).toEqual(
        calculationElement1Id
      );
      expect(device.CalculationElements[calculationElement1Id].Name).toEqual(
        calculationElement1Name
      );
      expect(
        device.CalculationElements[calculationElement1Id].Archived
      ).toEqual(calculationElement1Archived);
      expect(
        device.CalculationElements[calculationElement1Id].SampleTime
      ).toEqual(calculationElement1SampleTime);

      expect(device.CalculationElements[calculationElement2Id].Id).toEqual(
        calculationElement2Id
      );
      expect(device.CalculationElements[calculationElement2Id].Name).toEqual(
        calculationElement2Name
      );
      expect(
        device.CalculationElements[calculationElement2Id].Archived
      ).toEqual(calculationElement2Archived);
      expect(
        device.CalculationElements[calculationElement2Id].SampleTime
      ).toEqual(calculationElement2SampleTime);

      expect(device.CalculationElements[calculationElement3Id].Id).toEqual(
        calculationElement3Id
      );
      expect(device.CalculationElements[calculationElement3Id].Name).toEqual(
        calculationElement3Name
      );
      expect(
        device.CalculationElements[calculationElement3Id].Archived
      ).toEqual(calculationElement3Archived);
      expect(
        device.CalculationElements[calculationElement3Id].SampleTime
      ).toEqual(calculationElement3SampleTime);
    });

    it("should not create any calculationElements if there are no calculationElements in payload", async () => {
      calculationElement1Add = false;
      calculationElement2Add = false;
      calculationElement3Add = false;

      await exec();
      expect(device.CalculationElements).toEqual({});
    });
  });

  describe("get Events", () => {
    let name;
    let device;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      return device.Events;
    };

    it("should return EventEmitter of device", async () => {
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(device._events);
    });
  });

  describe("get Name", () => {
    let name;
    let device;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      return device.Name;
    };

    it("should return Name of device", async () => {
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(name);
    });
  });

  describe("get Variables", () => {
    let name;
    let device;
    let payload;

    beforeEach(() => {
      name = "test name";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      return device.Variables;
    };

    it("should return Name of device", async () => {
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(device._variables);
    });
  });

  describe("get ArchiveManagerInitialized", () => {
    let name;
    let device;
    let payload;
    let init;

    beforeEach(() => {
      name = "test name";
      init = true;
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      if (init) await device.init(payload);
      return device.ArchiveManagerInitialized;
    };

    it("should return true if archive manager is initialized", async () => {
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(true);
    });

    it("should return false if archive manager is initialized", async () => {
      init = false;
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(false);
    });
  });

  describe("get Variable", () => {
    let name;
    let device;
    let payload;
    let var1;
    let var2;
    let var3;
    let getId;

    beforeEach(() => {
      name = "test name";
      var1 = { Id: 101 };
      var2 = { Id: 102 };
      var3 = { Id: 103 };
      getId = 102;
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      device.addVariable(var1);
      device.addVariable(var2);
      device.addVariable(var3);
      return device.getVariable(getId);
    };

    it("should return variable of given id", async () => {
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(var2);
    });

    it("should return undefined if there is no variable of given id", async () => {
      getId = 1234;
      let result = await exec();

      expect(result).not.toBeDefined();
    });
  });

  describe("get Type", () => {
    let name;
    let device;
    let payload;
    let type;

    beforeEach(() => {
      name = "test name";
      type = "test type";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      device._type = type;
      return device.Type;
    };

    it("should return Type of device", async () => {
      let result = await exec();

      expect(result).toBeDefined();
      expect(result).toEqual(type);
    });
  });

  describe("get Payload", () => {
    let name;
    let payload;
    let device;

    beforeEach(() => {
      name = "test name";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      return device.Payload;
    };

    it("should return device payload", async () => {
      let result = await exec();

      let validPayload = {
        name: device.Name,
        id: device.Id
      };

      expect(result).toBeDefined();
      expect(result).toMatchObject(validPayload);
    });
  });

  describe("addVariable", () => {
    let name;
    let device;
    let variable;
    let variableId;
    let variableType;
    let variableValueType;
    let variableArchived;
    let payload;

    beforeEach(() => {
      name = "test name";
      variableType = "mbInt32";
      variableValueType = "integer";
      variableArchived = true;
      variableId = "test_variable";
    });

    let exec = async () => {
      variable = {
        Id: variableId,
        Type: variableType,
        ValueType: variableValueType,
        Archived: variableArchived
      };
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      return device.addVariable(variable);
    };

    it("should add variable to variables", async () => {
      await exec();

      expect(device.Variables[variableId]).toBeDefined();
      expect(device.Variables[variableId]).toEqual(variable);
    });

    it("should add variable to archive manager if variable is archived", async () => {
      variableArchived = true;

      await exec();

      //Checking if varaible is added to archive manager
      expect(
        device.ArchiveManager.doesVariableIdExists(variable.Id)
      ).toBeTruthy();
    });

    it("should not add variable to archive manager if variable is not archived", async () => {
      variableArchived = false;

      await exec();

      //Checking if varaible is added to archive manager
      expect(
        device.ArchiveManager.doesVariableIdExists(variable.Id)
      ).toBeFalsy();
    });

    it("should add variable again after it was deleted", async () => {
      await exec();
      await device.removeVariable(variable.Id);
      await device.addVariable(variable);
      expect(device.Variables[variableId]).toBeDefined();
      expect(device.Variables[variableId]).toEqual(variable);
    });

    it("should replace given variable if name already existis", async () => {
      await exec();
      let newVariable = { Id: variableId, Name: "new" };

      await device.addVariable(newVariable);
      expect(device.Variables[variableId]).not.toEqual(variable);
      expect(device.Variables[variableId]).toEqual(newVariable);
    });

    it("should create new column in database file based on variable id", async () => {
      variableArchived = true;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);
      let columnExists = await checkIfColumnExists(
        device.ArchiveManager.FilePath,
        "data",
        columnName,
        "INTEGER"
      );

      expect(columnExists).toBeTruthy();
    });

    it("should not create new column in database file based on variable id if variable archive if false", async () => {
      variableArchived = false;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);
      let columnExists = await checkIfColumnExists(
        device.ArchiveManager.FilePath,
        "data",
        columnName,
        "INTEGER"
      );

      expect(columnExists).toBeFalsy();
    });

    it("should create new column with Integer type in database file based on variable id and variable Integer type", async () => {
      variableValueType = "integer";
      variableArchived = true;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);
      let columnExists = await checkIfColumnExists(
        device.ArchiveManager.FilePath,
        "data",
        columnName,
        "INTEGER"
      );

      expect(columnExists).toBeTruthy();
    });

    it("should create new column with REAL type in database file based on variable id and variable Float type", async () => {
      variableValueType = "float";
      variableArchived = true;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);
      let columnExists = await checkIfColumnExists(
        device.ArchiveManager.FilePath,
        "data",
        columnName,
        "REAL"
      );

      expect(columnExists).toBeTruthy();
    });

    it("should create new column with INTEGER type in database file based on variable id and variable Boolean type", async () => {
      variableValueType = "boolean";
      variableArchived = true;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);
      let columnExists = await checkIfColumnExists(
        device.ArchiveManager.FilePath,
        "data",
        columnName,
        "INTEGER"
      );

      expect(columnExists).toBeTruthy();
    });

    it("should not throw if column already exists", async () => {
      variableArchived = true;

      await exec();
      await device.removeVariable(variableId);

      await expect(
        new Promise(async (resolve, reject) => {
          try {
            await device.addVariable(variable);
            resolve(true);
          } catch (err) {
            reject(err);
          }
        })
      ).resolves.toBeDefined();
    });
  });

  describe("removeVariable", () => {
    let name;
    let device;
    let variable;
    let variableId;
    let variableType;
    let variableValueType;
    let variableArchived;
    let payload;

    beforeEach(() => {
      name = "test name";
      variableId = "testVariable";
      variableValueType = "integer";
      variableType = "mbInt32";
      variableArchived = false;
    });

    let exec = async () => {
      variable = {
        Id: variableId,
        Type: variableType,
        ValueType: variableValueType,
        Archived: variableArchived
      };

      payload = { name: name };
      device = new Device();
      await device.init(payload);
      await device.addVariable(variable);
      await device.removeVariable(variableId);
    };

    it("should remove variable from variables", async () => {
      await exec();

      expect(device.Variables[variableId]).not.toBeDefined();
    });

    it("should remove variable from archive manager if it is archived", async () => {
      variableArchived = true;

      await exec();

      expect(device.Variables[variableId]).not.toBeDefined();
      expect(
        device.ArchiveManager.doesVariableIdExists(variableId)
      ).toBeFalsy();
    });

    it("should not remove variable column from database", async () => {
      variableArchived = true;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);
      let columnExists = await checkIfColumnExists(
        device.ArchiveManager.FilePath,
        "data",
        columnName,
        "INTEGER"
      );
      expect(columnExists).toBeTruthy();
    });

    it("should throw if there is no variable of such id", async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      await device.addVariable(variable);

      let newVariable = { Id: "new test Id" };

      await expect(
        new Promise(async (resolve, reject) => {
          try {
            await device.removeVariable(newVariable);
            return resolve(true);
          } catch (err) {
            return reject(err);
          }
        })
      ).rejects.toBeDefined();
    });
  });

  describe("divideVariablesByTickId", () => {
    let variable1;
    let variable2;
    let variable3;
    let variable4;
    let variable5;
    let variable6;
    let variable7;
    let variable8;
    let variable9;
    let variable10;
    let variables;

    beforeEach(() => {
      variable1 = { Name: "var1", TickId: 1 };
      variable2 = { Name: "var2", TickId: 1 };
      variable3 = { Name: "var3", TickId: 2 };
      variable4 = { Name: "var4", TickId: 2 };
      variable5 = { Name: "var5", TickId: 3 };
      variable6 = { Name: "var6", TickId: 3 };
      variable7 = { Name: "var7", TickId: 4 };
      variable8 = { Name: "var8", TickId: 4 };
      variable9 = { Name: "var9", TickId: 5 };
      variable10 = { Name: "var10", TickId: 5 };

      variables = [
        variable1,
        variable2,
        variable3,
        variable4,
        variable5,
        variable6,
        variable7,
        variable8,
        variable9,
        variable10
      ];
    });

    let exec = async () => {
      return Device.divideVariablesByTickId(variables);
    };

    it("should split variables by TickIds", async () => {
      let result = await exec();
      expect(result).toBeDefined();

      let allTickIds = Object.keys(result);
      expect(allTickIds.length).toEqual(5);

      expect(result).toMatchObject({
        "1": [variable1, variable2],
        "2": [variable3, variable4],
        "3": [variable5, variable6],
        "4": [variable7, variable8],
        "5": [variable9, variable10]
      });
    });

    it("should split variables by TickIds if there is only one tickIds", async () => {
      variable1 = { Name: "var1", TickId: 6 };
      variable2 = { Name: "var2", TickId: 6 };
      variable3 = { Name: "var3", TickId: 6 };
      variable4 = { Name: "var4", TickId: 6 };
      variable5 = { Name: "var5", TickId: 6 };
      variable6 = { Name: "var6", TickId: 6 };
      variable7 = { Name: "var7", TickId: 6 };
      variable8 = { Name: "var8", TickId: 6 };
      variable9 = { Name: "var9", TickId: 6 };
      variable10 = { Name: "var10", TickId: 6 };

      variables = [
        variable1,
        variable2,
        variable3,
        variable4,
        variable5,
        variable6,
        variable7,
        variable8,
        variable9,
        variable10
      ];

      let result = await exec();
      expect(result).toBeDefined();

      let allTickIds = Object.keys(result);
      expect(allTickIds.length).toEqual(1);

      expect(result).toMatchObject({
        "6": [
          variable1,
          variable2,
          variable3,
          variable4,
          variable5,
          variable6,
          variable7,
          variable8,
          variable9,
          variable10
        ]
      });
    });
  });

  describe("refresh", () => {
    let name;
    let payload;
    let device;
    let tickNumber;
    let _refreshMock;
    let _refreshMockResolvedValue;
    let eventEmitterMock;
    let eventEmitterMockEmitMethod;

    let sumElement1;
    let sumElement1Payload;
    let sumElement1Id;
    let sumElement1SampleTime;
    let sumElement1RefreshMockFunc;
    let sumElement1RefreshMockFuncResult;
    let addSumElement1;

    let sumElement2;
    let sumElement2Payload;
    let sumElement2Id;
    let sumElement2SampleTime;
    let sumElement2RefreshMockFunc;
    let sumElement2RefreshMockFuncResult;
    let addSumElement2;

    let sumElement3;
    let sumElement3Payload;
    let sumElement3Id;
    let sumElement3SampleTime;
    let sumElement3RefreshMockFunc;
    let sumElement3RefreshMockFuncResult;
    let addSumElement3;

    let fakeRefreshVariable;

    beforeEach(() => {
      name = "test name";
      tickNumber = 15;
      fakeRefreshVariable = {
        ArchiveTickId: 1,
        Value: 4321
      };
      _refreshMockResolvedValue = {
        "1234": fakeRefreshVariable
      };
      eventEmitterMockEmitMethod = jest.fn();
      eventEmitterMock = { emit: eventEmitterMockEmitMethod };

      sumElement1Id = "1001";
      sumElement1SampleTime = 1;

      sumElement2Id = "1002";
      sumElement2SampleTime = 2;

      sumElement3Id = "1003";
      sumElement3SampleTime = 3;

      sumElement1RefreshMockFuncResult = "refreshMock1";
      sumElement2RefreshMockFuncResult = "refreshMock2";
      sumElement3RefreshMockFuncResult = "refreshMock3";

      addSumElement1 = true;
      addSumElement2 = true;
      addSumElement3 = true;
    });

    let exec = async () => {
      payload = { name: name };

      sumElement1Payload = {
        id: sumElement1Id,
        name: "sumElement1",
        type: "sumElement",
        archived: false,
        unit: "",
        sampleTime: sumElement1SampleTime
      };

      sumElement2Payload = {
        id: sumElement2Id,
        name: "sumElement2",
        type: "sumElement",
        archived: false,
        unit: "",
        sampleTime: sumElement2SampleTime
      };

      sumElement3Payload = {
        id: sumElement3Id,
        name: "sumElement3",
        type: "sumElement",
        archived: false,
        unit: "",
        sampleTime: sumElement3SampleTime
      };

      _refreshMock = jest.fn().mockResolvedValue(_refreshMockResolvedValue);
      sumElement1RefreshMockFunc = jest
        .fn()
        .mockResolvedValue(sumElement1RefreshMockFuncResult);
      sumElement2RefreshMockFunc = jest
        .fn()
        .mockResolvedValue(sumElement2RefreshMockFuncResult);
      sumElement3RefreshMockFunc = jest
        .fn()
        .mockResolvedValue(sumElement3RefreshMockFuncResult);

      device = new Device();
      await device.init(payload);

      if (addSumElement1)
        sumElement1 = await device.createCalculationElement(sumElement1Payload);

      if (addSumElement2)
        sumElement2 = await device.createCalculationElement(sumElement2Payload);

      if (addSumElement3)
        sumElement3 = await device.createCalculationElement(sumElement3Payload);

      sumElement1.refresh = sumElement1RefreshMockFunc;
      sumElement2.refresh = sumElement2RefreshMockFunc;
      sumElement3.refresh = sumElement3RefreshMockFunc;

      device._refresh = _refreshMock;
      device._events = eventEmitterMock;

      return device.refresh(tickNumber);
    };

    it("should call _refresh method with tick arguments", async () => {
      let result = await exec();

      expect(_refreshMock).toHaveBeenCalledTimes(1);
      expect(_refreshMock.mock.calls[0][0]).toEqual(tickNumber);
    });

    it("should invoke Refreshed Event with _refresh result if refresh result is not empty", async () => {
      let result = await exec();

      expect(eventEmitterMockEmitMethod).toHaveBeenCalledTimes(1);
      expect(eventEmitterMockEmitMethod.mock.calls[0][0]).toEqual("Refreshed");
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][0]).toEqual(device);

      //Checking refresh object - refresh result value + refresh results of all calculation elements that suits tickNumber
      let refreshObjectResult = eventEmitterMockEmitMethod.mock.calls[0][1][1];

      expect(refreshObjectResult).toBeDefined();
      expect(Object.keys(refreshObjectResult).length).toEqual(3);
      expect(refreshObjectResult["1234"]).toEqual(fakeRefreshVariable);
      expect(refreshObjectResult[sumElement1Id]).toEqual(sumElement1);
      expect(refreshObjectResult[sumElement3Id]).toEqual(sumElement3);

      expect(eventEmitterMockEmitMethod.mock.calls[0][1][2]).toEqual(
        tickNumber
      );
    });

    it("should invoke Refreshed Event with empty object if refresh result is empty", async () => {
      //100 does not correspond with tickID = 15
      sumElement1SampleTime = 100;
      sumElement2SampleTime = 100;
      sumElement3SampleTime = 100;
      tickNumber = 15;

      _refreshMockResolvedValue = null;

      let result = await exec();

      expect(eventEmitterMockEmitMethod).toHaveBeenCalledTimes(1);
      expect(eventEmitterMockEmitMethod.mock.calls[0][0]).toEqual("Refreshed");
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][0]).toEqual(device);
      //Empty values - associated with calculation elements
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][1]).toEqual({});
      expect(eventEmitterMockEmitMethod.mock.calls[0][1][2]).toEqual(
        tickNumber
      );
    });
  });

  describe("_generatePayload", () => {
    let name;
    let payload;
    let device;

    beforeEach(() => {
      name = "test name";
    });

    let exec = async () => {
      payload = {
        name: name
      };
      device = new Device();
      await device.init(payload);
      return device._generatePayload();
    };

    it("should return device payload", async () => {
      let result = await exec();

      let validPayload = {
        name: device.Name,
        id: device.Id
      };

      expect(result).toBeDefined();
      expect(result).toMatchObject(validPayload);
    });
  });

  describe("editWithPayload", () => {
    let name;
    let payload;
    let device;
    let nameToEdit;
    let payloadToEdit;

    beforeEach(() => {
      name = "test name";
      nameToEdit = "new test name";
    });

    let exec = async () => {
      payload = { name: name };
      device = new Device();
      await device.init(payload);
      payloadToEdit = { name: nameToEdit };
      return device.editWithPayload(payloadToEdit);
    };

    it("should edit device according to payload", async () => {
      await exec();

      expect(device.Name).toBeDefined();
      expect(device.Name).toEqual(nameToEdit);
    });

    it("should not edit name if name is not defined in payload", async () => {
      nameToEdit = undefined;
      await exec();

      expect(device.Name).toBeDefined();
      expect(device.Name).toEqual(name);
    });
  });

  describe("archiveData", () => {
    let name;
    let device;
    let variable;
    let variableId;
    let variableType;
    let variableValueType;
    let variableArchived;
    let payload;
    let tickNumber;
    let archiveValue;
    let archivePayload;
    let archiveSampleTime;

    let insertSecondTime;
    let archiveSecondPayload;
    let tickNumberSecond;
    let archiveSecondValue;
    let variable2;

    beforeEach(() => {
      name = "test name";
      variableId = "testVariable";
      variableType = "mbInt32";
      variableValueType = "integer";
      variableArchived = true;
      tickNumber = 1234;
      archiveValue = 9876;
      insertSecondTime = false;

      tickNumberSecond = 1235;
      archiveSecondValue = 9877;
      archiveSampleTime = 1;
    });

    let exec = async () => {
      variable = {
        Id: variableId,
        Type: variableType,
        ValueType: variableValueType,
        Archived: variableArchived,
        Value: archiveValue,
        ArchiveTickId: archiveSampleTime
      };

      payload = { name: name };
      device = new Device();
      await device.init(payload);
      await device.addVariable(variable);

      archivePayload = {
        [variableId]: variable
      };

      if (insertSecondTime) {
        //Inserting two times almost at once

        variable2 = {
          Id: variableId,
          ValueType: variableType,
          Archived: variableArchived,
          Value: archiveSecondValue,
          ArchiveTickId: 1
        };

        archiveSecondPayload = {
          [variableId]: variable2
        };

        return Promise.all([
          device.archiveData(tickNumber, archivePayload),
          device.archiveData(tickNumberSecond, archiveSecondPayload)
        ]);
      } else {
        //Inserting one time
        return device.archiveData(tickNumber, archivePayload);
      }
    };

    it("should insert value into database of all variables where archiveTickId suits tickNumber", async () => {
      await exec();

      let valueFromDB = await device.getVariableValueFromDB(
        variableId,
        tickNumber
      );
      let columnName = device.ArchiveManager.getColumnNameById(variableId);

      let expectedPayload = { [tickNumber]: archiveValue };
      expect(valueFromDB).toEqual(expectedPayload);
    });

    it("should not insert value into database of all variables where archiveTickId don't suits tickNumber", async () => {
      archiveSampleTime = 99;
      await exec();

      let valueFromDB = await device.getVariableValueFromDB(
        variableId,
        tickNumber
      );
      let columnName = device.ArchiveManager.getColumnNameById(variableId);

      let expectedPayload = {};
      expect(valueFromDB).toEqual(expectedPayload);
    });

    it("should insert two values if invoked almost at one time", async () => {
      insertSecondTime = true;

      await exec();

      let columnName = device.ArchiveManager.getColumnNameById(variableId);

      let valueFromDB1 = await device.getVariableValueFromDB(
        variableId,
        tickNumber
      );
      let expectedPayload1 = { [tickNumber]: archiveValue };
      expect(valueFromDB1).toMatchObject(expectedPayload1);

      let valueFromDB2 = await device.getVariableValueFromDB(
        variableId,
        tickNumberSecond
      );
      let expectedPayload2 = {
        [tickNumberSecond]: archiveSecondValue
      };
      expect(valueFromDB2).toMatchObject(expectedPayload2);
    });
  });
});
